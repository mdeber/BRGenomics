% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ndimensional_binning.R
\name{binNdimensions}
\alias{binNdimensions}
\alias{aggregateByNdimensionalBins}
\alias{densityInNdimensionalBins}
\title{Generating and Aggregating Data Within N-dimensional Bins}
\usage{
binNdimensions(dims.df, nbins = 10, ncores = detectCores())

aggregateByNdimensionalBins(
  x,
  dims.df,
  nbins = 10,
  FUN = mean,
  ...,
  ignore.na = TRUE,
  drop = FALSE,
  empty = NA,
  ncores = detectCores()
)

densityInNdimensionalBins(dims.df, nbins = 10, ncores = detectCores())
}
\arguments{
\item{dims.df}{A dataframe containing one or more columns of numerical data
for which bins will be generated.}

\item{nbins}{Either a number giving the number of bins to use for all
dimensions (default = 10), or a vector containing the number of bins to use
for each dimension of input data given.}

\item{ncores}{Number of cores to use for computations.}

\item{x}{The name of the dimension in \code{dims.df} to aggregate, or a
separate numerical vector or dataframe of data to be aggregated. If
\code{x} is a numerical vector, each value in \code{x} corresponds to a row
of \code{dims.df}, and so \code{length(x)} must be equal to
\code{nrow(dims.df)}. Likewise, if \code{x} is a dataframe, \code{nrow(x)}
must equal \code{nrow(dims.df)}. Supplying a dataframe for \code{x} has the
advantage of simultaneously aggregating different sets of data, and
returning a single dataframe.}

\item{FUN}{A function to use for aggregating data within each bin.}

\item{...}{Additional arguments passed to \code{FUN}.}

\item{ignore.na}{Logical indicating if \code{NA} values of \code{x} should be
ignored. Default is \code{TRUE}.}

\item{drop}{A logical indicating if empty bin combinations should be removed
from the output. By default (\code{FALSE}), all possible combinations of
bins are returned, and empty bins contain a value given by \code{empty}.}

\item{empty}{When \code{drop = FALSE}, the value returned for empty bins. By
default, empty bins return \code{NA}. However, in many circumstances (e.g.
if \code{FUN = sum}), the empty value should be \code{0}.}
}
\value{
A dataframe.
}
\description{
Divide data along different dimensions into equally spaced bins, and
summarize the datapoints that fall into any of these n-dimensional bins.
}
\details{
These functions take in data along 1 or more dimensions, and for
  each dimension the data is divided into evenly-sized bins from the minimum
  value to the maximum value. For instance, if each row of \code{dims.df}
  were a gene, the columns (the different dimensions) would be various
  quantitative measures of that gene, e.g. expression level, number of exons,
  length, etc. If plotted in cartesian coordinates, each gene would be a
  single datapoint, and each measurement would be a separate dimension.

  \code{binNdimensions} returns the bin numbers themselves. The output
  dataframe has the same dimensions as the input \code{dims.df}, but each
  input data has been replaced by its bin number (an integer).

  \code{aggregateByNdimensionalBins} summarizes some input data \code{x} in
  each combination of bins, i.e. in each n-dimensional bin. Each row of the
  output dataframe is a unique combination of the input bins (i.e. each
  n-dimensional bin), and the output columns are identical to those in
  \code{dims.df}, with the addition of one or more columns containing the
  aggregated data in each n-dimensional bin. If the input \code{x} was a
  vector, the column is named "value"; if the input \code{x} was a dataframe,
  the column names from \code{x} are maintained.

  \code{densityInNdimensionalBins} returns a dataframe just like
  \code{aggregateByNdimensionalBins}, except the "value" column contains the
  number of observations that fall into each n-dimensional bin.
}
\examples{
data("PROseq") # import included PROseq data
data("txs_dm6_chr4") # import included transcripts

#--------------------------------------------------#
# find counts in promoter, early genebody, and near CPS
#--------------------------------------------------#

pr <- promoters(txs_dm6_chr4, 0, 100)
early_gb <- genebodies(txs_dm6_chr4, 500, 1000, fix.end = "start")
cps <- genebodies(txs_dm6_chr4, -500, 500, fix.start = "end")

df <- data.frame(counts_pr = getCountsByRegions(PROseq, pr),
                 counts_gb = getCountsByRegions(PROseq, early_gb),
                 counts_cps = getCountsByRegions(PROseq, cps))

#--------------------------------------------------#
# divide genes into 20 bins for each measurement
#--------------------------------------------------#

bin3d <- binNdimensions(df, nbins = 20, ncores = 1)

length(txs_dm6_chr4)
nrow(bin3d)
bin3d[1:6, ]

#--------------------------------------------------#
# get number of genes in each bin
#--------------------------------------------------#

bin_counts <- densityInNdimensionalBins(df, nbins = 20,
                                        ncores = 1)

bin_counts[1:6, ]

#--------------------------------------------------#
# get mean cps reads in bins of promoter and genebody reads
#--------------------------------------------------#

bin2d_cps <- aggregateByNdimensionalBins("counts_cps", df,
                                         nbins = 20, ncores = 1)

bin2d_cps[1:6, ]

subset(bin2d_cps, is.finite(value))[1:6, ]

#--------------------------------------------------#
# get median cps reads for those bins
#--------------------------------------------------#

bin2d_cps_med <- aggregateByNdimensionalBins("counts_cps", df, nbins = 20,
                                             FUN = median, ncores = 1)

bin2d_cps_med[1:6, ]

subset(bin2d_cps_med, is.finite(value))[1:6, ]
}
\author{
Mike DeBerardine
}
