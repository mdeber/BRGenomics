% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/signal_counting.R
\name{getCountsByRegions}
\alias{getCountsByRegions}
\alias{.getCoverageByRegions}
\title{Get signal counts in regions of interest}
\usage{
getCountsByRegions(
  dataset.gr,
  regions.gr,
  field = "score",
  NF = NULL,
  blacklist = NULL,
  melt = FALSE,
  region_names = NULL,
  expand_ranges = FALSE,
  ncores = detectCores()
)

.getCoverageByRegions(
  dataset.gr,
  regions.gr,
  field,
  NF,
  blacklist,
  melt,
  region_names,
  ncores
)
}
\arguments{
\item{dataset.gr}{A GRanges object in which signal is contained in metadata
(typically in the "score" field), or a named list of such GRanges objects.
If a list is given, a dataframe is returned containing the counts in each
region for each dataset.}

\item{regions.gr}{A GRanges object containing regions of interest.}

\item{field}{The metadata field of \code{dataset.gr} to be counted. If
\code{length(field) > 1}, a dataframe is returned containing the counts for
each region in each field. If \code{field} not found in
\code{names(mcols(dataset.gr))}, will default to using all fields found in
\code{dataset.gr}.}

\item{NF}{An optional normalization factor by which to multiply the counts.
If given, \code{length(NF)} must be equal to \code{length(field)}.}

\item{blacklist}{An optional GRanges object containing regions that should be
excluded from signal counting.}

\item{melt}{If \code{melt = TRUE}, a dataframe is returned containing a
column for regions and another column for signal. If multiple datasets are
given (if \code{dataset.gr} is a list or if \code{length(field) > 1}), the
output dataframe is melted to contain a third column indicating the sample
names. (See section on return values below).}

\item{region_names}{If \code{melt = TRUE}, an optional vector of names for
the regions in \code{regions.gr}. If left as \code{NULL}, indices of
\code{regions.gr} are used instead.}

\item{expand_ranges}{Logical indicating if ranges in \code{dataset.gr} should
be treated as descriptions of single molecules (\code{FALSE}), or if ranges
should be treated as representing multiple adjacent positions with the same
signal (\code{TRUE}). See details below.}

\item{ncores}{Multiple cores will only be used if \code{dataset.gr} is a list
of multiple datasets, or if \code{length(field) > 1}.}
}
\value{
An atomic vector the same length as \code{regions.gr} containing the
  sum of the signal overlapping each range of \code{regions.gr}. If
  \code{dataset.gr} is a list of multiple GRanges, or if \code{length(field)
  > 1}, a dataframe is returned. If \code{melt = FALSE} (the default),
  dataframes have a column for each dataset and a row for each region. If
  \code{melt = TRUE}, dataframes contain one column to indicate regions
  (either by their indices, or by \code{region_names}, if given), another
  column to indicate signal, and a third column containing the sample name
  (unless \code{dataset.gr} is a single GRanges object).
}
\description{
Get the sum of the signal in \code{dataset.gr} that overlaps each range in
\code{regions.gr}. If \code{expand_regions = FALSE},
\code{getCountsByRegions} is written to calculate \emph{readcounts}
overlapping each region, while \code{expand_regions = TRUE} will calculate
"coverage signal" (see details below).
}
\section{\code{expand_ranges = FALSE}}{
 In this configuration,
  \code{getCountsByRegions} is designed to work with data in which each range
  represents one type of molecule, whether it's a single base (e.g. the 5'
  ends, 3' ends, or centers of reads) or entire reads (i.e. paired 5' and 3'
  ends of reads).

  This is in contrast to standard run-length compressed GRanges object, as
  imported using \code{\link[rtracklayer:export]{rtracklayer::import.bw}}, in
  which a single range can represent multiple contiguous positions that share
  the same signal information.

  As an example, a range of covering 10 bp with a score of 2 is treated as 2
  reads (each spanning the same 10 bases), not 20 reads.
}

\section{\code{expand_ranges = TRUE}}{
 In this configuration, this function
  assumes that ranges in \code{dataset.gr} that cover multiple bases are
  compressed representations of multiple adjacent positions that contain the
  same signal. This type of representation is typical of "coverage" objects,
  including bedGraphs and bigWigs generated by many command line utilities.
  (But \emph{not} bigWigs as they are imported by
  \code{\link[BRGenomics:import_bigWig]{BRGenomics::import_bigWig}}).

  As an example, a range covering 10 bp with a score of 2 is treated as
  representing 20 signal counts, i.e. there are 10 adjacent positions that
  each contain a signal of 2.

  If the data truly represents basepair-resolution coverage, the "coverage
  signal" is equivalent to readcounts. However, users should take caution if
  the data is whole-read coverage, the "coverage signal" is determined by
  both the read counts as well as read lengths.
}

\examples{
data("PROseq") # load included PROseq data
data("txs_dm6_chr4") # load included transcripts

counts <- getCountsByRegions(PROseq, txs_dm6_chr4)

length(txs_dm6_chr4)
length(counts)
head(counts)

# Assign as metadata to the transcript GRanges
txs_dm6_chr4$PROseq <- counts

txs_dm6_chr4[1:6]
}
\seealso{
\code{\link[BRGenomics:getCountsByPositions]{getCountsByPositions}}
}
\author{
Mike DeBerardine
}
